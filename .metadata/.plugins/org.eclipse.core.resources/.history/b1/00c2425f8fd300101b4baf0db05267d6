package org.mql.generative.ai.services;

import org.mql.generative.ai.models.TranslationRequest;
import org.mql.generative.ai.models.TranslationResponse;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

@Service
public class TranslationService {

    @Value("${gemini.api.key}")
    private String apiKey;
    
    @Value("${gemini.api.url}")
    private String apiUrl;

    private static final HttpClient http = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();

    private static final ObjectMapper mapper = new ObjectMapper();

    public TranslationResponse translate(TranslationRequest request) {
        try {
        	String url = apiUrl + "?key=" + apiKey;

            String payload = """
                    {
                        "contents": [{
                            "parts": [{
                                "text": "Translate this text into Moroccan Darija. Return ONLY the translation: %s"
                            }]
                        }]
                    }
                    """.formatted(request.getText());

            HttpRequest httpRequest = HttpRequest.newBuilder()
                    .uri(new URI(url))
                    .header("Content-Type", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(payload))
                    .build();

            HttpResponse<String> response =
                    http.send(httpRequest, HttpResponse.BodyHandlers.ofString());

            String body = response.body();

            // -------------------------
            // Parse JSON de manière sûre
            // -------------------------
            JsonNode json = mapper.readTree(body);

         // Vérifier s'il y a une erreur
         if (json.has("error")) {
             String errorMsg = json.get("error").path("message").asText("Erreur inconnue de l'API");
             return new TranslationResponse("Erreur de l'API : " + errorMsg);
         }

         // Vérifier si le champ "candidates" existe
         JsonNode candidates = json.path("candidates");
         if (!candidates.isArray() || candidates.size() == 0) {
             return new TranslationResponse("Erreur : pas de candidats retournés par l'API");
         }

         // Vérifier le contenu
         JsonNode content = candidates.get(0).path("content");
         if (content.isMissingNode()) {
             return new TranslationResponse("Erreur : pas de contenu dans le candidat");
         }

         // Vérifier les parties
         JsonNode parts = content.path("parts");
         if (!parts.isArray() || parts.size() == 0) {
             return new TranslationResponse("Erreur : pas de parties dans le contenu");
         }

         // Vérifier le texte
         JsonNode textNode = parts.get(0).path("text");
         if (textNode.isMissingNode()) {
             return new TranslationResponse("Erreur : pas de texte dans la partie");
         }

         String translatedText = textNode.asText().trim();
         return new TranslationResponse(translatedText);

        } catch (Exception e) {
            return new TranslationResponse("Erreur lors de la traduction : " + e.getMessage());
        }
    }
}
